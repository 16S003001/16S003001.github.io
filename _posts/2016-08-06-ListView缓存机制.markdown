---
layout: post
title: "ListView缓存机制"
author: '#1121'
date: 2016-08-06 08:32:09 +0800
categories: [Android源码分析]
---

ListView大概是Android开发中最常用的组件之一了，本篇博客将对ListView的缓存机制进行一番探究。

![ListView继承结构](https://ooo.0o0.ooo/2016/08/05/57a5319dd2db7.png)

上图截取自Google的[官方文档](https://developer.android.com/reference/android/widget/ListView.html)，我们可以看出ListView的继承结构的层次较多，但是不难看出ListView也是一种ViewGroup，其中的每个列表项均是布局在该ViewGroup中的子视图。

这里先介绍一个现象，即使是再简单的View，其onLayout方法也至少会被调用两次。当然，ListView也不例外。

## __第一次layout过程__

由于ListView是View的子类，因此，若要布局子视图，onLayout方法便会被调用，我们先来看一下onLayout方法，不过在ListView中并未找到该方法的踪迹，经过一通找发现在AbsListView中重写了onLayout方法，把它贴出来：

{% highlight bash linenos %}
/**
 * Subclasses should NOT override this method but
 *  {@link #layoutChildren()} instead.
 */
@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    super.onLayout(changed, l, t, r, b);

    mInLayout = true;

    final int childCount = getChildCount();
    if (changed) {
        for (int i = 0; i < childCount; i++) {
            getChildAt(i).forceLayout();
        }
        mRecycler.markChildrenDirty();
    }

    layoutChildren();
    mInLayout = false;

    mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;

    // TODO: Move somewhere sane. This doesn't belong in onLayout().
    if (mFastScroll != null) {
        mFastScroll.onItemCountChanged(getChildCount(), mItemCount);
    }
}
{% endhighlight %}

该方法的注释上写道：子类不应该重写此方法而应该重写layoutChildren方法来代替。可以看到，在onLayout方法中调用了layoutChildren方法，跟进layoutChildren方法：

{% highlight bash linenos %}
/**
* Subclasses must override this method to layout their children.
*/
protected void layoutChildren() {
}
{% endhighlight %}

在AbsListView中这是一个空的方法，注释写道：子类必须重写该方法来布局他们的子视图。通过这句注释我们可以很清楚的知道，ListView的子视图是在该方法中完成的，那么我们跟进ListView中的layoutChildren方法：

{% highlight bash linenos %}
@Override
protected void layoutChildren() {

	...

    try {
        super.layoutChildren();

        invalidate();

        if (mAdapter == null) {
            resetList();
            invokeOnItemScrollListener();
            return;
        }

        final int childrenTop = mListPadding.top;
        final int childrenBottom = mBottom - mTop - mListPadding.bottom;
        final int childCount = getChildCount();

        int index = 0;
        int delta = 0;

        View sel;
        View oldSel = null;
        View oldFirst = null;
        View newSel = null;

        ...

        // Pull all children into the RecycleBin.
        // These views will be reused if possible
        final int firstPosition = mFirstPosition;
        final RecycleBin recycleBin = mRecycler;
        if (dataChanged) {
            for (int i = 0; i < childCount; i++) {
                recycleBin.addScrapView(getChildAt(i), firstPosition+i);
            }
        } else {
            recycleBin.fillActiveViews(childCount, firstPosition);
        }

        // Clear out old views
        detachAllViewsFromParent();
        recycleBin.removeSkippedScrap();

        switch (mLayoutMode) {
        case LAYOUT_SET_SELECTION:
            if (newSel != null) {
                sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);
            } else {
                sel = fillFromMiddle(childrenTop, childrenBottom);
            }
            break;
        case LAYOUT_SYNC:
            sel = fillSpecific(mSyncPosition, mSpecificTop);
            break;
        case LAYOUT_FORCE_BOTTOM:
            sel = fillUp(mItemCount - 1, childrenBottom);
            adjustViewsUpOrDown();
            break;
        case LAYOUT_FORCE_TOP:
            mFirstPosition = 0;
            sel = fillFromTop(childrenTop);
            adjustViewsUpOrDown();
            break;
        case LAYOUT_SPECIFIC:
            sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);
            break;
        case LAYOUT_MOVE_SELECTION:
            sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);
            break;
        default:
            if (childCount == 0) {
                if (!mStackFromBottom) {
                    final int position = lookForSelectablePosition(0, true);
                    setSelectedPositionInt(position);
                    sel = fillFromTop(childrenTop);
                } else {
                    final int position = lookForSelectablePosition(mItemCount - 1, false);
                    setSelectedPositionInt(position);
                    sel = fillUp(mItemCount - 1, childrenBottom);
                }
            } else {
                if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
                    sel = fillSpecific(mSelectedPosition,
                            oldSel == null ? childrenTop : oldSel.getTop());
                } else if (mFirstPosition < mItemCount) {
                    sel = fillSpecific(mFirstPosition,
                            oldFirst == null ? childrenTop : oldFirst.getTop());
                } else {
                    sel = fillSpecific(0, childrenTop);
                }
            }
            break;
        }

        // Flush any cached views that did not get reused above
        recycleBin.scrapActiveViews();

        ...
            
        mLayoutMode = LAYOUT_NORMAL;
        mDataChanged = false;

        ...

    } finally {
        if (!blockLayoutRequests) {
            mBlockLayoutRequests = false;
        }
    }
}
{% endhighlight %}

这个方法相当的长，在此截取了我认为与本文主题具有较大相关性的部分。

17-19行，在这里声明了三个变量childrenTop、childrenBottom以及childCount，其含义如下：

* childrenTop，赋值为ListView的上内边距，即子视图布局在y轴上的上边界
* childrenBottom，赋值为`mBottom - mTop - mListPadding.bottom`，`mBottom - mTop`即为ListView的高度，再减去ListView的下内边距，即子视图布局在y轴上的下边界
* childCount，赋值为`getChildCount`，即ViewGroup中的子视图个数（屏幕上最多能显示的子视图的个数），在第一次layout过程中，由于之前没有任何子视图被添加到ListView中，因此childCount在第一次layout的过程中为0

33-34行，声明了firstPosition变量，赋值为mFirstPosition（需要注意的是，mFirstPosition的注释为`The position of the first child displayed`，即屏幕上显示的第一个子视图的位置，关于这个位置的定义应该是指子视图在ListView的所有列表项中的位置）；声明了recycleBin变量，赋值为mRecycler，这个变量的类型为RecycleBin类型，这个类可以说是ListView缓存机制的核心类，接下来对这个类分析一波。

#### __插播一条  ListView缓存机制的核心类——RecycleBin__

下面贴出了这个类的部分代码，截取了一些目前我理解了的部分。

{% highlight bash linenos %}
/**
 * The RecycleBin facilitates reuse of views across layouts. The RecycleBin has two levels of
 * storage: ActiveViews and ScrapViews. ActiveViews are those views which were onscreen at the
 * start of a layout. By construction, they are displaying current information. At the end of
 * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews are old views that
 * could potentially be used by the adapter to avoid allocating views unnecessarily.
 *
 * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener)
 * @see android.widget.AbsListView.RecyclerListener
 */
class RecycleBin {

    /**
     * The position of the first view stored in mActiveViews.
     */
    private int mFirstActivePosition;

    /**
     * Views that were on screen at the start of layout. This array is populated at the start of
     * layout, and at the end of layout all view in mActiveViews are moved to mScrapViews.
     * Views in mActiveViews represent a contiguous range of Views, with position of the first
     * view store in mFirstActivePosition.
     */
    private View[] mActiveViews = new View[0];

    /**
     * Unsorted views that can be used by the adapter as a convert view.
     */
    private ArrayList<View>[] mScrapViews;

    private int mViewTypeCount;

    private ArrayList<View> mCurrentScrap;

    private ArrayList<View> mSkippedScrap;

    public void setViewTypeCount(int viewTypeCount) {
        if (viewTypeCount < 1) {
            throw new IllegalArgumentException("Can't have a viewTypeCount < 1");
        }
        //noinspection unchecked
        ArrayList<View>[] scrapViews = new ArrayList[viewTypeCount];
        for (int i = 0; i < viewTypeCount; i++) {
            scrapViews[i] = new ArrayList<View>();
        }
        mViewTypeCount = viewTypeCount;
        mCurrentScrap = scrapViews[0];
        mScrapViews = scrapViews;
    }

    /**
     * Fill ActiveViews with all of the children of the AbsListView.
     *
     * @param childCount The minimum number of views mActiveViews should hold
     * @param firstActivePosition The position of the first view that will be stored in
     *        mActiveViews
     */
    void fillActiveViews(int childCount, int firstActivePosition) {
        if (mActiveViews.length < childCount) {
            mActiveViews = new View[childCount];
        }
        mFirstActivePosition = firstActivePosition;

        //noinspection MismatchedReadAndWriteOfArray
        final View[] activeViews = mActiveViews;
        for (int i = 0; i < childCount; i++) {
            View child = getChildAt(i);
            AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();
            // Don't put header or footer views into the scrap heap
            if (lp != null && lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                // Note:  We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views.
                //        However, we will NOT place them into scrap views.
                activeViews[i] = child;
                // Remember the position so that setupChild() doesn't reset state.
                lp.scrappedFromPosition = firstActivePosition + i;
            }
        }
    }

    /**
     * Get the view corresponding to the specified position. The view will be removed from
     * mActiveViews if it is found.
     *
     * @param position The position to look up in mActiveViews
     * @return The view if it is found, null otherwise
     */
    View getActiveView(int position) {
        int index = position - mFirstActivePosition;
        final View[] activeViews = mActiveViews;
        if (index >=0 && index < activeViews.length) {
            final View match = activeViews[index];
            activeViews[index] = null;
            return match;
        }
        return null;
    }

    /**
     * @return A view from the ScrapViews collection. These are unordered.
     */
    View getScrapView(int position) {
        final int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap < 0) {
            return null;
        }
        if (mViewTypeCount == 1) {
            return retrieveFromScrap(mCurrentScrap, position);
        } else if (whichScrap < mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
        return null;
    }

    /**
     * Puts a view into the list of scrap views.
     * <p>
     * If the list data hasn't changed or the adapter has stable IDs, views
     * with transient state will be preserved for later retrieval.
     *
     * @param scrap The view to add
     * @param position The view's position within its parent
     */
    void addScrapView(View scrap, int position) {
        final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
        if (lp == null) {
            // Can't recycle, but we don't know anything about the view.
            // Ignore it completely.
            return;
        }

        lp.scrappedFromPosition = position;

        // Remove but don't scrap header or footer views, or views that
        // should otherwise not be recycled.
        final int viewType = lp.viewType;
        if (!shouldRecycleViewType(viewType)) {
            // Can't recycle. If it's not a header or footer, which have
            // special handling and should be ignored, then skip the scrap
            // heap and we'll fully detach the view later.
            if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                getSkippedScrap().add(scrap);
            }
            return;
        }

        scrap.dispatchStartTemporaryDetach();

        // The the accessibility state of the view may change while temporary
        // detached and we do not allow detached views to fire accessibility
        // events. So we are announcing that the subtree changed giving a chance
        // to clients holding on to a view in this subtree to refresh it.
        notifyViewAccessibilityStateChangedIfNeeded(
                AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);

        // Don't scrap views that have transient state.
        final boolean scrapHasTransientState = scrap.hasTransientState();
        if (scrapHasTransientState) {
            if (mAdapter != null && mAdapterHasStableIds) {
                // If the adapter has stable IDs, we can reuse the view for
                // the same data.
                if (mTransientStateViewsById == null) {
                    mTransientStateViewsById = new LongSparseArray<>();
                }
                mTransientStateViewsById.put(lp.itemId, scrap);
            } else if (!mDataChanged) {
                // If the data hasn't changed, we can reuse the views at
                // their old positions.
                if (mTransientStateViews == null) {
                    mTransientStateViews = new SparseArray<>();
                }
                mTransientStateViews.put(position, scrap);
            } else {
                // Otherwise, we'll have to remove the view and start over.
                getSkippedScrap().add(scrap);
            }
        } else {
            if (mViewTypeCount == 1) {
                mCurrentScrap.add(scrap);
            } else {
                mScrapViews[viewType].add(scrap);
            }

            if (mRecyclerListener != null) {
                mRecyclerListener.onMovedToScrapHeap(scrap);
            }
        }
    }

    /**
     * Move all views remaining in mActiveViews to mScrapViews.
     */
    void scrapActiveViews() {
        final View[] activeViews = mActiveViews;
        final boolean hasListener = mRecyclerListener != null;
        final boolean multipleScraps = mViewTypeCount > 1;

        ArrayList<View> scrapViews = mCurrentScrap;
        final int count = activeViews.length;
        for (int i = count - 1; i >= 0; i--) {
            final View victim = activeViews[i];
            if (victim != null) {
                final AbsListView.LayoutParams lp
                        = (AbsListView.LayoutParams) victim.getLayoutParams();
                final int whichScrap = lp.viewType;

                activeViews[i] = null;

                if (victim.hasTransientState()) {
                    // Store views with transient state for later use.
                    victim.dispatchStartTemporaryDetach();

                    if (mAdapter != null && mAdapterHasStableIds) {
                        if (mTransientStateViewsById == null) {
                            mTransientStateViewsById = new LongSparseArray<View>();
                        }
                        long id = mAdapter.getItemId(mFirstActivePosition + i);
                        mTransientStateViewsById.put(id, victim);
                    } else if (!mDataChanged) {
                        if (mTransientStateViews == null) {
                            mTransientStateViews = new SparseArray<View>();
                        }
                        mTransientStateViews.put(mFirstActivePosition + i, victim);
                    } else if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                        // The data has changed, we can't keep this view.
                        removeDetachedView(victim, false);
                    }
                } else if (!shouldRecycleViewType(whichScrap)) {
                    // Discard non-recyclable views except headers/footers.
                    if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                        removeDetachedView(victim, false);
                    }
                } else {
                    // Store everything else on the appropriate scrap heap.
                    if (multipleScraps) {
                        scrapViews = mScrapViews[whichScrap];
                    }

                    victim.dispatchStartTemporaryDetach();
                    lp.scrappedFromPosition = mFirstActivePosition + i;
                    scrapViews.add(victim);

                    if (hasListener) {
                        mRecyclerListener.onMovedToScrapHeap(victim);
                    }
                }
            }
        }

        pruneScrapViews();
    }

}
{% endhighlight %}

首先对类中的一些字段进行说明：

* `mFirstActivePosition`，存储在mActiveViews中的第一个子视图的位置（在所有列表项中的位置）
* `mActiveViews`，View类型的一维数组，在layout过程开始时显示在屏幕上的子视图，这些子视图是一组相邻的视图，第一个子视图的位置存储在mFirstActivePosition中
* `mScrapViews`，可被Adapter作为convertView使用的无序的子视图，ArrayList<View>类型的一维数组，其中数组的长度与mViewTypeCount相对应
* `mViewTypeCount`，子视图的类型个数
* `mCurrentScrap`，ArrayList<View>类型，当前所使用的复用数组
* `mSkippedScrap`，无法重用的子视图，存储于这个数组中，最终会被从父视图中detach掉

下面对几个方法进行说明：

* `setViewTypeCount()`，设置ListView的子视图的类型的个数，最小为1，同时将数组mScrapViews的长度置为mViewTypeCount，将mCurrentScrap置为mScrapViews的第一个元素
* `fillActiveViews()`，将AbsListView的子视图填充到mActiveViews中
* `getActiveView()`，根据指定位置从mActiveViews中获取视图，若在数组中找到了对应的子视图那么将该子视图从数组中删除
* `getScrapView()`，根据指定位置从mScrapViews中获取视图，首先会判断该位置对应的子视图的类型，然后判断子视图类型个数，若为1，由于之前已经设置了mCurrentScrap为mScrapViews的第一个元素因此直接使用mCurrentScrap即可，若大于1，则根据视图类型获取mScrapViews中的对应元素在从中查找
* `addScrapView()`，将一个视图加入到可重用的视图之中
* `scrapActiveViews()`，将mActiveViews中的所有视图加入到mScrapViews中

#### __接着回到第一次layout过程中__

在layoutChildrent的34行，声明了一个RecycleBin实例，获得了核心神器。

35-41行，这里是一个if判断，判断的条件是dataChanged，这个变量被赋值为mDataChanged的值，关于mDataChanged我们再来说点题外话：

> 通过阅读ListView的setAdapter方法不难得知，ListView和Adapter使用了观察者模式，ListView是观察者，Adapter是被观察者，ListView订阅了Adapter的数据变更事件，当数据发生变更时，通过调用Adapter的notifyDataSetChanged方法向ListView发出通知，ListView被告知数据发生了变化时会将mDataChanged置为true，同时，在layoutChildren方法的末尾，mDataChanged会被重新设置为false。

那么，在这个if判断中，由于ListView并未收到数据变更的通知，因此dataChanged的值为false，所以我们进入到else代码块，在这里调用了RecycleBin的方法，由于此时childCount为0，所以这一步实际并未进行什么操作。

44-45行，调用detachAllViewsFromParent将所有子视图从ListView中detach掉，调用RecycleBin的removeSkippedScrap将mSkippedScrap中的所有子视图从其父视图中detach掉。

47－96行，一个switch语句，对mLayoutMode进行判断，很容易找到，mLayoutMode的默认值为LAYOUT_NORMAL，同时在layoutChildren方法的末尾会对这个字段进行重置，那么在这个switch语句中，一般我们会进入到default分支，在这个分支中有很多if，第一次layout过程中，childCount为0，同时除非是经过设置，mStackFromBottom一般为false（mStackFromBottom即列表从下向上展开，一般我们使用ListView都是从上至下展开的），接下来会调用fillFromTop方法，跟进fillFromTop方法：

{% highlight bash linenos %}
/**
 * Fills the list from top to bottom, starting with mFirstPosition
 *
 * @param nextTop The location where the top of the first item should be
 *        drawn
 *
 * @return The view that is currently selected
 */
private View fillFromTop(int nextTop) {
    mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);
    mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);
    if (mFirstPosition < 0) {
        mFirstPosition = 0;
    }
    return fillDown(mFirstPosition, nextTop);
}
{% endhighlight %}

在fillFromTop方法内，首先对mFirstPosition的值做了一番检查，在第一次layout过程中，显然经过这一通检查，最后mFirstPosition的值为0，nextTop的值是我们之前声明的childrenTop的值，然后调用fillDown方法，跟进fillDown方法：

{% highlight bash linenos %}
/**
 * Fills the list from pos down to the end of the list view.
 *
 * @param pos The first position to put in the list
 *
 * @param nextTop The location where the top of the item associated with pos
 *        should be drawn
 *
 * @return The view that is currently selected, if it happens to be in the
 *         range that we draw.
 */
private View fillDown(int pos, int nextTop) {
    View selectedView = null;

    int end = (mBottom - mTop);
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        end -= mListPadding.bottom;
    }

    while (nextTop < end && pos < mItemCount) {
        // is this the selected item?
        boolean selected = pos == mSelectedPosition;
        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);

        nextTop = child.getBottom() + mDividerHeight;
        if (selected) {
            selectedView = child;
        }
        pos++;
    }

    setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);
    return selectedView;
}
{% endhighlight %}

在fillDown方法内，首先计算了ListView的高度并赋值给end变量，end变量即子视图布局时的下部边界，若子视图的top位置大于或等于这个值，显然这个子视图是无法显示在屏幕上的，因此便没有必要再将这个子视图添加到屏幕上，根据这个原则设置了下面的循环，nextTop（即下一个需要布局的子视图的top位置）初始值为子视图布局的上部边界，循环继续的条件为`nextTop小于end即处于屏幕可视的范围内并且pos小于列表项的总数`。

下面我们来看下在这个循环内部做了什么，首先对selected字段赋值，按照我的理解mSelectedPosition的值为0，那么当pos为0的时候该字段会被置为true，接下来调用makeAndAddView方法并将返回值赋值给child字段，从方法名很容易知道这个方法创建了一个子视图并将其添加到ListView中，至于方法内部的细节等会儿再说，接下来的操作是将nextTop和pos的值向前迭代，nextTop的值被置为`child.getBottom() + mDividerHeight`，显然，下一个子视图的top位置就是当前已经添加到ListView中的子视图的bottom位置加上分割线的高度，pos只需进行加一操作即可。

现在我们来看一下makeAndAddView方法的实现：

{% highlight bash linenos %}
/**
 * Obtain the view and add it to our list of children. The view can be made
 * fresh, converted from an unused view, or used as is if it was in the
 * recycle bin.
 *
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow If flow is true, align top edge to y. If false, align bottom
 *        edge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return View that was added
 */
private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
        boolean selected) {
    View child;


    if (!mDataChanged) {
        // Try to use an existing view for this position
        child = mRecycler.getActiveView(position);
        if (child != null) {
            // Found it -- we're using an existing child
            // This just needs to be positioned
            setupChild(child, position, y, flow, childrenLeft, selected, true);

            return child;
        }
    }

    // Make a new view for this position, or convert an unused view if possible
    child = obtainView(position, mIsScrap);

    // This needs to be positioned and measured
    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

    return child;
}
{% endhighlight %}

在makeAndAddView方法内，由于mDataChanged为false，因此会进入if代码块，尝试从RecycleBin中的mActiveViews获取子视图，显然在第一次layout过程中是获取不到的，因此child此时为空，那么便会调用下面的obtainView方法来获得child，来看一下obtainView方法：

{% highlight bash linenos %}
/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 *                the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position, boolean[] isScrap) {
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "obtainView");

    isScrap[0] = false;

    ...

    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;

            // Finish the temporary detach started in addScrapView().
            child.dispatchFinishTemporaryDetach();
        }
    }

    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }

    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }

    setItemViewLayoutParams(child, position);

    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }

    Trace.traceEnd(Trace.TRACE_TAG_VIEW);

    return child;
}
{% endhighlight %}

首先将isScrap[0]置为false，接下来尝试从RecycleBin的mScrapViews中获取scrapView，显然得到的会是null，那么接下来调用Adapter的getView方法，__这里很关键，不难发现，这个方法就是我们在自定义ListView的Adapter时经常重写的getView方法，这里传入的参数scrapView就是我们在getView方法利用到的convertView__，接下来由于scarpView为null，因此直接将child返回，这里要注意的是，mIsScrap[0]为false，即表示该子视图不是经过复用得到的。

回到makeAndAddView方法，接下来会调用setupChild方法，并将我们得到的子视图child和mIsScrap[0]作为参数传入，跟进setupChild方法：

{% highlight bash linenos %}
/**
 * Add a view as a child and make sure it is measured (if necessary) and
 * positioned properly.
 *
 * @param child The view to add
 * @param position The position of this child
 * @param y The y position relative to which this view will be positioned
 * @param flowDown If true, align top edge to y. If false, align bottom
 *        edge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param recycled Has this view been pulled from the recycle bin? If so it
 *        does not need to be remeasured.
 */
private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,
        boolean selected, boolean recycled) {

    ...

    if ((recycled && !p.forceAdd) || (p.recycledHeaderFooter
            && p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) {
        attachViewToParent(child, flowDown ? -1 : 0, p);
    } else {
        p.forceAdd = false;
        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            p.recycledHeaderFooter = true;
        }
        addViewInLayout(child, flowDown ? -1 : 0, p, true);
    }

    ...

}
{% endhighlight %}

截取了部分代码片段，这里的recycled值便是我们之前传入的mIsScrap[0]，对这一部分的if-else代码块进行一下说明：

* 若child是通过复用重新绑定数据获得的，那么mIsScrap[0]会被置为true，即recycled为true，那么会使得attachViewToParent方法被调用，在该方法的注释中有这样一句：`This method should be called only for views which were detached from their parent.`，这个方法只能被从父视图中detach掉的子视图调用，显然若我们复用了之前的子视图，显然之前的子视图已经被detach了，要想将其重新加入到ListView之中，我们只需调用attachViewToParent方法即可
* 若child是通过getView方法中使用LayoutInflater来创建的，那么mIsScrap[0]会被置为false，即recycled为false，那么会使得addViewInLayout方法得到调用，该方法用来在layout过程中向ViewGroup添加一个新的子视图

那么通过调用makeAndAddView方法，一个子视图便被成功地加入到了ListView中，然后，通过fillDown方法内设置的循环，子视图会被不断地加入到屏幕中直至屏幕被填充满或者所有列表项均已被添加到ListView中。

这便是第一次layout的过程，对第一次layout做下总结：

> 倘若屏幕能显示5个列表项，那么无论ListView需要展示的数据的大小是10还是100还是1000，只有前5个列表项会被加载并显示在屏幕上，其余的并不会被加载。同时，在第一次layout过程中并不存在任何的复用，5个被加载的列表项是通过LayoutInflater或其他方式进行加载的。

## __第二次layout过程__

现在我们来看第二次layout过程，继续来看layoutChildren方法。

17-19行，childrenTop和childrenBottom仍是和第一次layout时相同的作用，不过这时childCount已经变成了我们在第一次layout过程中加载的子视图的数量，现在来说一下mChidlrenCount的值是在何时发生了变化。

#### __讲一下mChildrenCount是何时发生变化的__

在layout过程中，我们若要将子视图添加到ListView容器中有两种方法，一个是调用attachViewToParent，另一个是调用addViewInLayout，这两个方法的第二个参数都为index，而我们传入的值均为-1，这两个方法最终都调用了addInArray方法，同时在调用该方法前都对index字段通过如下方法进行校正：

{% highlight bash linenos %}
if (index < 0) {
    index = mChildrenCount;
}
{% endhighlight %}

由于我们传入的index始终为-1，因此通过此步校正，index被赋值为mChildrenCount的值并作为参数传入addInArray方法，接下来我们看下addInArray方法：

{% highlight bash linenos %}
private void addInArray(View child, int index) {
    View[] children = mChildren;
    final int count = mChildrenCount;
    final int size = children.length;
    if (index == count) {
        if (size == count) {
            mChildren = new View[size + ARRAY_CAPACITY_INCREMENT];
            System.arraycopy(children, 0, mChildren, 0, size);
            children = mChildren;
        }
        children[mChildrenCount++] = child;
    } else if (index < count) {
        if (size == count) {
            mChildren = new View[size + ARRAY_CAPACITY_INCREMENT];
            System.arraycopy(children, 0, mChildren, 0, index);
            System.arraycopy(children, index, mChildren, index + 1, count - index);
            children = mChildren;
        } else {
            System.arraycopy(children, index, children, index + 1, count - index);
        }
        children[index] = child;
        mChildrenCount++;
        if (mLastTouchDownIndex >= index) {
            mLastTouchDownIndex++;
        }
    } else {
        throw new IndexOutOfBoundsException("index=" + index + " count=" + count);
    }
}
{% endhighlight %}

在第五行的判断`if (index == count)`，若从attachViewToParent或addViewInLayout中调用的话，这一行判断是始终为真的，因此会进入到if代码块中，其中第十一行`children[mChildrenCount++] = child;`，通过这一行代码，完成了mChildrenCount的累加以及对mChildren数组的赋值，最终，通过在fillDown方法中设置的循环，mChildrenCount会被设置为屏幕所能显示的子视图的个数（在上面的例子中为5），屏幕上的子视图从上至下依次被加入到mChildren数组中。

#### __接着回到第二次layout过程中__

继续看layoutChildren方法。

35-41行，在第二次layout过程中仍然会进入else分支，但不同的是此时传入的参数childCount已经变为我们之前添加到容器中的子视图的总数了，在fillActiveViews中，将mActiveViews设置为childCount长度的数组，然后将我们在第一次layout过程中加载到容器中的子视图依次填充到mActiveViews数组中。

44-45行，detachAllViewsFromParent的调用将第一次layout加载的所有子视图从容器中detach，同时将children数组置为空，将mChildrenCount置为0。removeSkippedScrap的调用此时依然是没啥用的。

47-96行，switch语句，此时仍然会进入default分支，然后进入else代码块，这里有几个判断，由于在第一次layout过程中mSelectedPosition被设置为0，因此会进入第一个if代码块，调用fillSpecific方法，跟进fillSpecific方法：

{% highlight bash linenos %}
/**
 * Put a specific item at a specific location on the screen and then build
 * up and down from there.
 *
 * @param position The reference view to use as the starting point
 * @param top Pixel offset from the top of this view to the top of the
 *        reference view.
 *
 * @return The selected view, or null if the selected view is outside the
 *         visible area.
 */
private View fillSpecific(int position, int top) {
    boolean tempIsSelected = position == mSelectedPosition;
    View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected);
    // Possibly changed again in fillUp if we add rows above this one.
    mFirstPosition = position;

    View above;
    View below;

    final int dividerHeight = mDividerHeight;
    if (!mStackFromBottom) {
        above = fillUp(position - 1, temp.getTop() - dividerHeight);
        // This will correct for the top of the first view not touching the top of the list
        adjustViewsUpOrDown();
        below = fillDown(position + 1, temp.getBottom() + dividerHeight);
        int childCount = getChildCount();
        if (childCount > 0) {
            correctTooHigh(childCount);
        }
    } else {
        below = fillDown(position + 1, temp.getBottom() + dividerHeight);
        // This will correct for the bottom of the last view not touching the bottom of the list
        adjustViewsUpOrDown();
        above = fillUp(position - 1, temp.getTop() - dividerHeight);
        int childCount = getChildCount();
        if (childCount > 0) {
             correctTooLow(childCount);
        }
    }

    if (tempIsSelected) {
        return temp;
    } else if (above != null) {
        return above;
    } else {
        return below;
    }
}
{% endhighlight %}

这个方法的主要作用是先加载指定位置的子视图，然后再加载其上边的和下边的子视图，由于我们传入的position值为0，因此会继续调用fillDown方法，同理会在循环中调用makeAndAddView方法，但这次会有所不同，区别发生在下面这一部分：

{% highlight bash linenos %}
if (!mDataChanged) {
    // Try to use an existing view for this position
    child = mRecycler.getActiveView(position);
    if (child != null) {
        // Found it -- we're using an existing child
        // This just needs to be positioned
        setupChild(child, position, y, flow, childrenLeft, selected, true);

        return child;
    }
}
{% endhighlight %}

由于之前我们已经使用第一次layout过程中加载的子视图填充了mActiveViews，因此这次我们尝试调用getActiveView方法是可以获取到非空的子视图的，那么便不需要再去调用obtainView方法，直接setupChild即可，同时，由于这次我们获取到的子视图是通过复用得到的，因此recycled参数我们传入true，在setupChild方法中调用attachViewToParent方法重新将子视图attach即可。

最后，99行，将mActiveViews清空。

这便是第二次layout的过程，对第二次layout过程做下总结：

> 在第二次layout过程中，会将第一次layout加载的子视图全部detach并填充到mActiveViews以供复用，然后在makeAndAddView方法中直接复用之前存储的mActiveViews中的视图而不再去inflate新的视图，因此在第二次layout后，屏幕仍显示和第一次layout后相同的子视图，只是第二次layout过程中复用了第一次layout过程中创建的视图，从而大大提高了效率。

## __滑动过程中的复用__

通过上面的一通分析，我们已经知道了加载ListView时，ListView只会加载前几个能显示在屏幕上的列表项，对于其他的列表项不做加载，若要显示其他列表项则需要进行滑动操作，那么下面来探究滑动过程中的复用。首先，ListView是一个ViewGroup，本身并不具有可滑动的属性，因此若要实现列表上下滑动的效果则要对Touch事件进行特殊处理，而我们需要重点关注的Touch事件显然就是ACTION_MOVE事件。我们先来看一下onTouchEvent方法：

{% highlight bash linenos %}
@Override
public boolean onTouchEvent(MotionEvent ev) {

	...

    switch (actionMasked) {
        case MotionEvent.ACTION_DOWN: {
            onTouchDown(ev);
            break;
        }

        case MotionEvent.ACTION_MOVE: {
            onTouchMove(ev, vtev);
            break;
        }

        case MotionEvent.ACTION_UP: {
            onTouchUp(ev);
            break;
        }

        case MotionEvent.ACTION_CANCEL: {
            onTouchCancel();
            break;
        }

        case MotionEvent.ACTION_POINTER_UP: {
            onSecondaryPointerUp(ev);
            final int x = mMotionX;
            final int y = mMotionY;
            final int motionPosition = pointToPosition(x, y);
            if (motionPosition >= 0) {
                // Remember where the motion event started
                final View child = getChildAt(motionPosition - mFirstPosition);
                mMotionViewOriginalTop = child.getTop();
                mMotionPosition = motionPosition;
            }
            mLastY = y;
            break;
        }

        case MotionEvent.ACTION_POINTER_DOWN: {
            // New pointers take over dragging duties
            final int index = ev.getActionIndex();
            final int id = ev.getPointerId(index);
            final int x = (int) ev.getX(index);
            final int y = (int) ev.getY(index);
            mMotionCorrection = 0;
            mActivePointerId = id;
            mMotionX = x;
            mMotionY = y;
            final int motionPosition = pointToPosition(x, y);
            if (motionPosition >= 0) {
                // Remember where the motion event started
                final View child = getChildAt(motionPosition - mFirstPosition);
                mMotionViewOriginalTop = child.getTop();
                mMotionPosition = motionPosition;
            }
            mLastY = y;
            break;
        }
    }

    ...

    return true;
}
{% endhighlight %}

可以看到在处理ACTION_MOVE事件时调用了onTouchMove方法，在onTouchMove方法中处理TOUCH_MODE_SCROLL和TOUCH_MODE_OVERSCROLL又调用了scrollIfNeeded方法，跟进scrollIfNeeded方法：

{% highlight bash linenos %}
private void scrollIfNeeded(int x, int y, MotionEvent vtev) {
    
	...

    final int deltaY = rawDeltaY;
    int incrementalDeltaY =
            mLastY != Integer.MIN_VALUE ? y - mLastY + scrollConsumedCorrection : deltaY;
    int lastYCorrection = 0;

    if (mTouchMode == TOUCH_MODE_SCROLL) {
        
        ...

        if (y != mLastY) {
            
        	...

            boolean atEdge = false;
            if (incrementalDeltaY != 0) {
                atEdge = trackMotionScroll(deltaY, incrementalDeltaY);
            }

            ...

        }
    } else if (mTouchMode == TOUCH_MODE_OVERSCROLL) {
        if (y != mLastY) {

        	...

            if (incrementalDeltaY != 0) {
                
                ...

                trackMotionScroll(incrementalDeltaY, incrementalDeltaY);

                ...

            }

            ...

        }
    }
}
{% endhighlight %}

该方法的名称为scrollIfNeeded，很明显就是，如果有必要的话进行滑动，那么我们可以判断出ListView的滑动效果应该就是在这里产生的，在19行，声明了一个int型变量incrementalDeltaY，并赋值为从开始按下的ACTION_DOWN事件到现在正在处理的ACTION_MOVE事件手指在y轴上滑动的距离，那么接着往下看，我们会看到若incrementalDeltaY不为0的话便会调用trackMotionScroll方法，跟进trackMotionScroll方法：

{% highlight bash linenos %}
/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 *        began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */
boolean trackMotionScroll(int deltaY, int incrementalDeltaY) {
    
	...

    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }

    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }

    ...

    final boolean down = incrementalDeltaY < 0;

    ...

    int start = 0;
    int count = 0;

    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }

    ...

    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }

    ...

    if (down) {
        mFirstPosition += count;
    }

    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }

    ...

    return false;
}
{% endhighlight %}

13-23行，对deltaY和incrementalDeltaY进行边界检查。

27行，声明down变量，赋值为`incrementalDeltaY < 0`，关于这个变量的含义，一开始我理解的是用户向下滑动，但后来发现这么理解是有问题的，`incrementalDeltaY < 0`的时候明显是用户手指上移，而当用户手指上移的时候，列表是向下展开的，因此关于down变量的含义可以理解为列表向下滑动与否，当`incrementalDeltaY < 0`为真的时候，用户手指上移，列表向下展开，为假的时候，用户手指下移，列表向上展开，弄清这个变量的含义很关键。

31-32行，定义了start和count变量，其中这两个变量联合起来用于判断需要从屏幕中移除的子视图的范围，即起始于start的count个子视图需要从屏幕中detach。

34-75行，一个if-else代码块，判定条件为down变量，说明如下：

* 若down为真，则说明列表是向下展开的，则列表项从屏幕下方进入、从屏幕上方离开，在35行声明了一个变量top，赋值为`-incrementalDeltaY`，由于现在处于预滑动阶段（即对相关变量进行了设置，但还没有重新布局相关视图的位置），因此top变量的含义是：top值对应的位置在进行滑动后将成为滑动后的新视图的顶部，通过下图进行示意，左图是滑动前，右图是滑动后，通过手指上移使左图过渡到右图，那么top的位置已经标注在左图上，在滑动后，这个位置成为了新的顶部位置。由于子视图是从屏幕上方离开的，因此我们从上至下遍历当前处于屏幕中的子视图，若当前遍历的子视图的bottom不小于top，那么显然该子视图在滑动后仍然会处于屏幕中，同时其后的子视图也会仍处于屏幕中，因此可以跳出遍历；若当前遍历的子视图的bottom小于top，那么显然滑动后该子视图不会再在屏幕中显示，因此我们需要将该视图添加到mScrapViews中以供重用

![滑动前](https://ooo.0o0.ooo/2016/08/06/57a5ff7399f1a.jpg)
![滑动后](https://ooo.0o0.ooo/2016/08/06/57a5ff738d727.jpg)

* 若down为false，则说明列表是向上展开的，则列表项从屏幕上方进入、从屏幕下方离开，在55行声明了一个变量bottom，赋值为`getHeight() - incrementalDeltaY`，设置这个变量的作用和上面的top变量的作用是类似的，由于子视图是从屏幕下方离开的，因此我们从下至上遍历当前处于屏幕中的子视图，若当前遍历的子视图的top不大于bottom，那么显然该子视图在滑动后仍然会处于屏幕中，同时其前的子视图也会仍处于屏幕中，因此可以跳出遍历；若当前子视图的top值大于bottom，那么显然滑动后该子视图不会再在屏幕中显示，因此我们需要将该视图添加到mScrapViews中以供重用

79-82行，若count大于0，说明从start起的count个子视图已经被移至mScrapViews中以供重用，因此需要从容器中detach掉。

86-88行，若列表向下移动，则给mFirstPosition加上count。

90-93行，这里调用了fillGap方法，并将down作为参数传入，我们跟进fillGap方法：

{% highlight bash linenos %}
/**
 * Fills the gap left open by a touch-scroll. During a touch scroll, children that
 * remain on screen are shifted and the other ones are discarded. The role of this
 * method is to fill the gap thus created by performing a partial layout in the
 * empty space.
 *
 * @param down true if the scroll is going down, false if it is going up
 */
@Override
void fillGap(boolean down) {
    final int count = getChildCount();
    if (down) {
        int paddingTop = 0;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            paddingTop = getListPaddingTop();
        }
        final int startOffset = count > 0 ? getChildAt(count - 1).getBottom() + mDividerHeight :
                paddingTop;
        fillDown(mFirstPosition + count, startOffset);
        correctTooHigh(getChildCount());
    } else {
        int paddingBottom = 0;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            paddingBottom = getListPaddingBottom();
        }
        final int startOffset = count > 0 ? getChildAt(0).getTop() - mDividerHeight :
                getHeight() - paddingBottom;
        fillUp(mFirstPosition - 1, startOffset);
        correctTooLow(getChildCount());
    }
}
{% endhighlight %}

在fillGap中，根据down的值我们调用fillDown或fillUp方法来加载一个新进入到屏幕中的子视图，我们以fillDown方法为例，关注的重点仍然为makeAndAddView方法。

21行，尝试从mActiveViews中获取可重用的视图，由于mActiveViews已经被清空，因此child为null。

32行，调用obtainView方法，这时我们尝试从mScrapViews中获取可重用的视图，由于之前我们尝试寻找在滑动后会被移除的视图，并将这些视图加入到mScrapViews中，因此此时child是有不为null的可能的，若不为null则重新绑定数据并将此复用的子视图重新attach到容器中，若为null则仍然进行inflate操作然后add到容器中。

至此，活动过程中的复用机制便分析完毕了，下面我们通过例子来对上述分析进行一个验证。

## __例子__

在这里贴出自定义的Adapter的代码：

{% highlight bash linenos %}
private class ImageListAdapter extends ArrayAdapter<String> {

    public ImageListAdapter(Context context) {
        super(context, 0);
    }

    @Override
    public int getCount() {
        return mDatas.size();
    }

    @Override
    public String getItem(int position) {
        return mDatas.get(position);
    }

    @Override
    public int getViewTypeCount() {
        return 2;
    }

    @Override
    public int getItemViewType(int position) {
        return position == 4 ? 1 : 0;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        Log.d(TAG, convertView == null ? "convertView is null" : "convertView is not null");

        ViewHolder holder;
        if (convertView == null) {
            convertView = LayoutInflater.from(getContext()).inflate(R.layout.list_item, parent, false);

            holder = new ViewHolder();
            holder.image = (ImageView) convertView.findViewById(R.id.image);

            convertView.setTag(holder);
        } else {
            holder = (ViewHolder) convertView.getTag();
        }

        String imagePath = getItem(position);
        downloadImage(imagePath, holder.image);

        return convertView;
    }

    class ViewHolder {

        ImageView image;

    }
}
{% endhighlight %}

![1](https://ooo.0o0.ooo/2016/08/06/57a69aa8af585.jpg)
![2](https://ooo.0o0.ooo/2016/08/06/57a69aa8c7396.jpg)


![3](https://ooo.0o0.ooo/2016/08/06/57a69a6e68852.jpg)
![4](https://ooo.0o0.ooo/2016/08/06/57a69c6b006d7.jpg)

{% highlight bash linenos %}
08-07 10:13:33.600 22398-22398/com.guoyonghui.listviewlearning D/MainActivity: convertView is null
08-07 10:13:33.697 22398-22398/com.guoyonghui.listviewlearning D/MainActivity: convertView is null
08-07 10:13:33.702 22398-22398/com.guoyonghui.listviewlearning D/MainActivity: convertView is null
08-07 10:13:42.541 22398-22398/com.guoyonghui.listviewlearning D/MainActivity: convertView is null
08-07 10:13:46.874 22398-22398/com.guoyonghui.listviewlearning D/MainActivity: convertView is null
08-07 10:13:57.249 22398-22398/com.guoyonghui.listviewlearning D/MainActivity: convertView is not null
{% endhighlight %}

* 图一，加载第一屏的三张图片，通过控制台输出可以看到convertView均为null
* 图二，第四张图片进入屏幕，但由于第一张图片还未离开屏幕，因此此时没有任何视图被缓存，所以第四张图片仍使用LayoutInflater进行加载，通过控制台输出可以看到加载第四张图片的时候convertView仍为null
* 图三，当第五张图片进入屏幕的时候，第一张图片已经移出屏幕并被缓存起来，但是由于第一张图片对应的ViewType是0，而第五张图片（即position＝4的位置）对应的ViewType是1，因此加载第五张图片会从ViewType为1的缓存中尝试获取视图，显然我们并未缓存任何视图到ViewType为1的缓存中，因此通过控制台可以看到，加载第五张图片的时候convertView仍为null
* 图四，当第六张图片（ViewType为0）进入屏幕的时候，同种视图类型的图片一图片二已经被缓存起来，因此我们可以看到图片六的位置开始时显示的是第二张图片（因为图片是异步加载的），这是因为它重用了第二张图片的视图，从控制台可以看到这时的convertView就不为null了

通过这个例子很好的对ListView的缓存机制进行了说明，经过分析，我们现在已经可以很容易地知道一件事：

> ListView用来展示列表需要创建的子视图的个数最多为第一屏的子视图的个数加一，在滑动屏幕加载其他列表项的时候，只需复用最开始创建的子视图即可。

至此，ListView的缓存机制已经分析完毕，由于代码较多，一些细节还未仔细推敲，后续会继续补上。

__[Source Code](https://github.com/Guomato/ListViewLearning)__