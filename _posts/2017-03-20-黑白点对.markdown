---
layout: post
title: "黑白点对"
author: '#1121'
date: 2017-03-20 14:54:56 +0800
categories: [分治法]
---

来自算法课的作业again。

给定平面上的n个白点和n个黑点，任意三点不共线，试设计一个分治算法将每个白点与一个黑点相连，使得所有连线互不相交。

## 准备工作

在设计算法之前先证明一个命题成立。

> 将n个白球与n+1个黑球排成一列，则至少有一个黑球，其左侧的白球与黑球数相等。

将球从左到右编号为1、2、3...2n、2n+1，使用反证法来证明这个命题是成立的，首先**假设不存在这样的黑球，使得其左侧的白球与黑球数相等**。

接下来证明在这个假设成立的前提下，下面这个命题是成立的。

> 不存在黑球，其左侧的白球个数少于黑球。

仍然使用反证法，即**假设存在某个黑球，其左侧的白球个数少于黑球**，我们将具有这样性质的黑球的最小编号记为i，球i左侧的第一个黑球的编号记为j，若i与j之间没有白球（即i与j是相邻的），由于i左侧的白球个数是少于黑球的，那么显然j的左侧的白球个数是等于黑球的（否则若j的左侧白球个数大于黑球，那么i的左侧白球的个数是大于等于黑球的，矛盾），**这与我们第一个假设成立的前提相矛盾**，因此i与j之间至少存在一个白球，因此有下面的不等式成立：

* j左侧的白球数量 <= i左侧的白球数量 - 1
* j左侧的黑球数量 = i左侧的黑球数量 - 1
* i左侧的白球数量 < i左侧的黑球数量

将这三个不等式联立即有：

**j左侧的白球数量 < j左侧的黑球数量**

即编号的j的黑球其左侧的白球数量小于黑球数量，又因为**i < j**，所以i不是具有这样的性质的黑球的最小编号，矛盾。

**所以在第一个假设成立的前提下，不存在黑球，其左侧的白球个数少于黑球。**

现在我们考虑最右的黑球，显然其左侧有n个黑球，那么其左侧白球的数量呢？由于前提是第一个假设成立，因此其左侧的白球数量不可能是n，而同时白球的总数只有n个，因此其左侧的白球数量一定小于n（即其左侧黑球的数量），**这与在第一个假设成立的前提下，不存在黑球，其左侧的白球个数少于黑球相矛盾**，因此第一个假设是不成立的，即**将n个白球与n+1个黑球排成一列，则至少有一个黑球，其左侧的白球与黑球数相等，命题得证。同时很容易得出这样的黑球其右侧的白球数与黑球数也是相等的**。

证明完了这个命题，下面我们来考虑算法的设计。

## 思路

由于是要设计的算法是分治法，因此首先考虑划分阶段，在这个阶段我们需要先找到一个原点，这个点具有这样的特征：**在所有的点中，它具有最小的y值，同时若有多个具有最小y值的点，那么该点的x值是最小的**，寻找这个原点的意义是什么呢？从原点特征的定义中可以看出，所有点与原点的连线与x轴正向所成角度的范围都是**[0°, 180°)**，同时由于任意三点不共线，所以每个点相对应的角度都是唯一的，我们不妨设原点的颜色是白色，然后根据点与原点的连线与x轴正向所成角度由小到大将这些点排序，**这样我们便得到了有n个黑点和n-1个白点组成的序列**，根据一开始我们证明的命题，一定存在某个黑点使得其顺时针一侧的白球与黑球数相等，同时其逆时针一侧的白球与黑球数也相等，而且这点与原点的颜色是相异的。那么划分阶段所需要做的所有工作便是找到这样的一个点（上面的分析说明了这个点是一定存在的），我们可以按夹角由小到大的顺序扫描点集，并记录当前已经扫描过的黑白点的数量，**若扫描到某一点时，该点与原点具有相异的颜色，同时已经扫描过的点中黑白点具有相同的数量，那么该点便是我们需要的划分点**。这样，我们便将问题划分为了两个子问题，子问题中的黑白点都是均匀的。

接下来便是不断地递归来求解子问题，显然，当问题的规模（即黑白点的总数）为2时便可以停止继续向下递归。在该算法中没有merge阶段。

## 代码

{% highlight base linenos %}
def match(a, left, right, pairs):
    if left > right:
        return
    elif left == right - 1:
        pairs.append((a[left], a[right]))
    else:
        a[left:right + 1] = sorted(a[left:right + 1], key=lambda point: (point[1], point[0]))
        zero = left
        a[left + 1:right + 1] = sorted(a[left + 1:right + 1], key=lambda point: (point[0] - a[zero][0]) / distance(point, a[zero]), reverse=True)

        index = left + 1
        count0 = 0
        count1 = 0

        while not (a[zero][2] != a[index][2] and count0 == count1):
            if a[zero][2] == a[index][2]:
                count0 += 1
            else:
                count1 += 1
            index += 1

        pairs.append((a[zero], a[index]))

        match(a, left + 1, index - 1, pairs)
        match(a, index + 1, right, pairs)

        return
{% endhighlight %}

## 正确性分析

下面使用数学归纳法来证明算法的正确性。

1. 当n=1时（n为黑点或白点的数量，总数为2n），算法显然是正确的。
2. 假设当n=k时算法是正确的，往证当n=k+1时算法也是正确的。
3. 当n=k+1时，将我们找到的原点和划分点分别记做P₀和P₁，P₀P₁顺时针一侧的部分和逆时针一侧的部分中的白点数和黑点数相等且不大于k，因此在每个部分上算法都可以正确运行。又因为任意三点不共线，所以不会有任何黑白点对的连线和P₀P₁交叉，而P₀P₁本身也是一条黑白点对的连线，因此当n=k+1时，算法是正确的。

综上所述，算法可以正确运行。




